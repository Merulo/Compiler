Block FourthIR::getMeetingBlock(Block&b)
{
    //find the meeting block
    std::vector<Block> ls;
    std::vector<Block> rs;
    std::vector<std::string> lv = {b.blockName};
    std::vector<std::string> rv = {b.blockName};
    traverse(getBlockByName(b.blockIfTrue, _notYetConvertedBlocks), ls, lv);
    traverse(getBlockByName(b.blockIfFalse, _notYetConvertedBlocks), rs, rv);
    
    for(auto& l : ls)
    {
        for(auto& r : rs)
        {
            if (l == r)
            {
                std::cout<<"meeting block is "<<r.blockName<<std::endl;
                return r;
            }
        }
    }
    std::cout<<"PROBLEM1 in traverse, no matching found"<<std::endl;
    if (lv.front() == lv.back())
    {
        std::cout<<"loop starting in "<<lv.front()<< " via "<<lv[1]<<std::endl;
    }
    if (rv.front() == rv.back())
    {
        std::cout<<"loop starting in "<<rv.front()<< " via "<<rv[1]<<std::endl;
    }

    return b;
}

void FourthIR::traverse(Block& b, std::vector<Block>& blocks, std::vector<std::string>& visited)
{
    std::cout<<"\tADDING "<<b.blockName<<std::endl;
    if (visited.front() == b.blockName)
    {
        blocks.push_back(b);
        visited.push_back(b.blockName);
        return;
    }
    
    visited.push_back(b.blockName);

    blocks.push_back(b);
    if (!b.blockJump.empty())
    {
        traverse(getBlockByName(b.blockJump, _notYetConvertedBlocks), blocks, visited);
        return;
    }
    else if (!b.blockIfFalse.empty() && !b.blockIfTrue.empty())
    {
        //find the meeting block
        std::vector<Block> ls;
        std::vector<Block> rs;
        traverse(getBlockByName(b.blockIfTrue, _notYetConvertedBlocks), ls, visited);
        traverse(getBlockByName(b.blockIfFalse, _notYetConvertedBlocks), rs, visited);
        
        for(auto& l : ls)
        {
            for(auto& r : rs)
            {
                if (l == r)
                {
                    blocks.push_back(r);
                    traverse(r, blocks, visited);
                    return;
                }
            }
        }
        std::cout<<"PROBLEM2 in traverse, no matching found"<<std::endl; 
    }
}

void FourthIR::appendSaveOfVariable(Block& target, Block& meeting, RegisterBlock& copy, Register& reg, Block& last)
{
    if (target != meeting && meeting != last)
    {
        auto lines = prepareRegisterWithoutLoading(copy, reg, last, "");
        Block& toInsertT = getBlockByName(last.blockName, _blocks);
        lines.insert(lines.begin(), {"#saving register" + reg.name + " content"});
        lines.push_back({"#end of saving register" + reg.name + " content"});
        toInsertT.lines.insert(toInsertT.lines.end() - 1, lines.begin(), lines.end());
    }    
}

void FourthIR::mergeRegisters(
    std::vector<Register>& regT, std::vector<Register>& regF, 
    Block& t, Block& f, 
    RegisterBlock& copyForT, RegisterBlock& copyForF,
    Block& lastT, Block& lastF,
    Block& meeting, RegisterBlock& rb)
{
    for(size_t i = 0; i < regT.size(); i++)
    {
        // std::cout<<"comparing "<<regT[i] <<" and "<<regF[i]<<std::endl;
        if (regT[i].shouldSave(regF[i]))
        {
            // std::cout<<"should save"<<std::endl;
            appendSaveOfVariable(t, meeting, copyForT, regT[i], lastT);
            appendSaveOfVariable(f, meeting, copyForF, regF[i], lastF);
            rb.setUnkown(i);
        }
        else
        {
            rb.setRegister(i, regF[i]);
        }
    }
}

Block& FourthIR::handleSplit(Block& b, RegisterBlock rb, Block& lastBlock)
{
    std::cout<<"meeting block= "<<std::endl;
    Block meeting = getMeetingBlock(b);
    if (meeting == b)
    {
        std::cout<<"MEETING BLOCK WAS NOT FOUND! for "<<b.blockName<<std::endl;
        return b;
    }

    std::cout<<"meeting block= "<<meeting.blockName<<std::endl;
    Block& t = getBlockByName(b.blockIfTrue, _notYetConvertedBlocks);
    Block& f = getBlockByName(b.blockIfFalse, _notYetConvertedBlocks);

    RegisterBlock copyForT(rb);
    RegisterBlock copyForF(rb);
    Block lastT = meeting;
    Block lastF = meeting;

    if (t != meeting)
    {
        lastT = convertBlockToAssembler(t, copyForT, meeting);
    }
    if (f != meeting)
    {
        lastF = convertBlockToAssembler(f, copyForF, meeting);
    }

    std::cout<<"merge of registers"<<std::endl;

    // copyForT.print();
    // copyForF.print();
    auto regT = copyForT.getRegisters();
    auto regF = copyForF.getRegisters();

    mergeRegisters(regT, regF, t, f, copyForT, copyForF, lastT, lastF, meeting, rb);

    rb.setAddressRegisterAsUnkown();
    return convertBlockToAssembler(meeting, rb, lastBlock);
}

Block& FourthIR::continueConverting(Block& b, RegisterBlock rb, Block& lastBlock)
{
    if (!b.blockJump.empty())
    {
        Block next = getBlockByName(b.blockJump, _notYetConvertedBlocks);
        if (next == lastBlock)
        {
            return b;
        }
        return convertBlockToAssembler(next, rb, lastBlock);
    }
    else if (!b.blockIfFalse.empty() && !b.blockIfTrue.empty())
    {
        return handleSplit(b, rb, lastBlock);
    }
    return b;
}